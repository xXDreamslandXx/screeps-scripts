module.exports.loop = function () {
    const spawn = Game.spawns['Spawn1'];

    // Stel de rol in voor specifieke creeps
    if (Game.creeps['Harvester6646387']) {
        Game.creeps['Harvester6646387'].memory.role = 'harvester';
    }
    if (Game.creeps['Harvester6645387']) {
        Game.creeps['Harvester6645387'].memory.role = 'harvester';
    }

    // Spawning creeps logica
    const maxHarvesters = 3;
    const maxBouwers = 2;
    const maxOnderhouders = 1;

    const harvesters = _.filter(Game.creeps, (creep) => creep.memory.role === 'harvester');
    const bouwers = _.filter(Game.creeps, (creep) => creep.memory.role === 'bouwer');
    const onderhouders = _.filter(Game.creeps, (creep) => creep.memory.role === 'onderhouder');

    if (harvesters.length < maxHarvesters) {
        const harvesterName = 'harvester' + (harvesters.length + 1).toString().padStart(2, '0');
        spawn.spawnCreep([WORK, CARRY, MOVE], harvesterName, { memory: { role: 'harvester' } });
    } else if (bouwers.length < maxBouwers) {
        const bouwerName = 'bouwer' + (bouwers.length + 1).toString().padStart(2, '0');
        spawn.spawnCreep([WORK, CARRY, MOVE], bouwerName, { memory: { role: 'bouwer' } });
    } else if (onderhouders.length < maxOnderhouders) {
        const onderhoudNaam = 'onderhouder' + (onderhouders.length + 1).toString().padStart(2, '0');
        spawn.spawnCreep([WORK, CARRY, MOVE], onderhoudNaam, { memory: { role: 'onderhouder' } });
    }

    // Loop door alle creeps
    for (const name in Game.creeps) {
        const creep = Game.creeps[name];

        if (creep.memory.role === 'harvester') {
            runHarvester(creep);
        } else if (creep.memory.role === 'bouwer') {
            runBouwer(creep);
        } else if (creep.memory.role === 'onderhouder') {
            runOnderhouder(creep);
        }
    }
};

// Functie voor de Harvester: Energie oogsten en afleveren in een container of spawn
function runHarvester(creep) {
    if (creep.store.getFreeCapacity() > 0) {
        const source = creep.pos.findClosestByPath(FIND_SOURCES);
        if (creep.harvest(source) === ERR_NOT_IN_RANGE) {
            creep.moveTo(source, { visualizePathStyle: { stroke: '#ffaa00' } });
        }
    } else {
        // Lever energie aan container of spawn
        const container = creep.pos.findClosestByPath(FIND_STRUCTURES, {
            filter: (structure) => structure.structureType === STRUCTURE_CONTAINER && structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0
        });
        if (container) {
            if (creep.transfer(container, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
                creep.moveTo(container, { visualizePathStyle: { stroke: '#ffffff' } });
            }
        } else {
            // Als er geen container is, lever dan energie aan de spawn
            if (creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
                creep.moveTo(Game.spawns['Spawn1'], { visualizePathStyle: { stroke: '#ffffff' } });
            }
        }
    }
}

// Functie voor de Bouwer: Energie ophalen uit containers en vervolgens bouwen
function runBouwer(creep) {
    if (creep.store[RESOURCE_ENERGY] === 0) {
        const container = creep.pos.findClosestByPath(FIND_STRUCTURES, {
            filter: (structure) => structure.structureType === STRUCTURE_CONTAINER && structure.store[RESOURCE_ENERGY] > 0
        });
        if (container && creep.withdraw(container, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.moveTo(container, { visualizePathStyle: { stroke: '#ffffff' } });
        }
    } else {
        const constructionSite = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);
        if (constructionSite && creep.build(constructionSite) === ERR_NOT_IN_RANGE) {
            creep.moveTo(constructionSite, { visualizePathStyle: { stroke: '#ffffff' } });
        }
    }
}

// Functie voor de Onderhouder: Onderhoud wegen, containers en upgrade de Room Controller
function runOnderhouder(creep) {
    if (creep.store[RESOURCE_ENERGY] === 0) {
        const container = creep.pos.findClosestByPath(FIND_STRUCTURES, {
            filter: (structure) => structure.structureType === STRUCTURE_CONTAINER && structure.store[RESOURCE_ENERGY] > 0
        });
        if (container && creep.withdraw(container, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
            creep.moveTo(container, { visualizePathStyle: { stroke: '#ffffff' } });
        }
    } else {
        // Onderhoud van wegen en containers
        const closestDamagedStructure = creep.pos.findClosestByPath(FIND_STRUCTURES, {
            filter: (structure) => (structure.structureType === STRUCTURE_ROAD || structure.structureType === STRUCTURE_CONTAINER) && structure.hits < structure.hitsMax
        });
        if (closestDamagedStructure && creep.repair(closestDamagedStructure) === ERR_NOT_IN_RANGE) {
            creep.moveTo(closestDamagedStructure, { visualizePathStyle: { stroke: '#ffffff' } });
        } else {
            // Room Controller upgraden als er geen reparatie nodig is
            if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) {
                creep.moveTo(creep.room.controller, { visualizePathStyle: { stroke: '#ffffff' } });
            }
        }
    }
}

// Functie om containers en wegen te plaatsen
function placeRoadAndContainers() {
    const room = Game.rooms[Object.keys(Game.rooms)[0]];
    const sources = room.find(FIND_SOURCES);

    for (const source of sources) {
        const containerNearSource = source.pos.findInRange(FIND_STRUCTURES, 1, {
            filter: { structureType: STRUCTURE_CONTAINER }
        }).length;

        if (!containerNearSource) {
            source.pos.createConstructionSite(STRUCTURE_CONTAINER);
        }

        // Plaats wegen rond de bron
        const roadPos = new RoomPosition(source.pos.x + 1, source.pos.y, source.pos.roomName);
        if (!roadPos.lookFor(LOOK_CONSTRUCTION_SITES).length) {
            roadPos.createConstructionSite(STRUCTURE_ROAD);
        }
    }
}
